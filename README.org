#+title: Untexify - a bad clone of [[https://detexify.kirelabs.org/classify.html][Detexify]]
#+STARTUP:     latexpreview
#+STARTUP:     nologdone
#+PROPERTY: header-args:html :session first :exports both :results output :tangle codeblocks.py :comments link :noweb-ref 0 :noweb yes
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
# DONE: Make this past-tense
* What this is
:PROPERTIES:
:ID:       1223610a-f1de-4bef-b2c7-63c388b82739
:END:
Untexify is a handwriting-to- $\LaTeX$ dictionary. $\LaTeX$ is the most popular markup language for technical documents in mathematics, and is widely used throughout computer science and industry.

However, its mnemonic conventions for symbols are old and debatably antiquated. Many beginning researchers and students of the sciences find difficulty remembering the $\LaTeX$ name for a certain symbol. Untexify is an interactive canvas which will return the closest $\LaTeX$ code for any symbol drawn on it.

This is accomplished using an OCR machine learning model written in Python using TensorFlow, which is then ran in a webapp created with [[https://www.djangoproject.com/][Django]] and hosted online with the help of [[https://fly.io/][fly.io]].

The training dataset was not hand-drawn, like in the case of many other MNIST-like models. Rather, it was programmatically generated using an image-transformation pipeline created with the [[https://albumentations.ai/][Albumentations]] library. This way, I didn't have to find or write myself thousands of hand-drawn $\LaTeX$ symbols.

This entire project was planned and conceived in the lovely [[https://orgmode.org/][Org-mode]], as Emacs is my primary development environment. The website was itself written as a series of HTML and Javascript codeblocks which were tangled together using Org-mode's exporting functionality.

* Road Map
:PROPERTIES:
:ID:       416c080b-4f18-4c40-b3ce-836a6542b37e
:END:
1. Backend
   1. Create the dataset
      1) Pull a large list of symbols from the [[https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols][OEIS]]
         I simply copied a table's symbols and formatted them into a file such that each piece of $\LaTeX$ was on its own line.
      2) Convert the images into .png files
         I used [[https://github.com/mtyrolski/latex2image.git][latex2image]] to convert the list of commands into small, square images of each symbol. The program is a bit finnicky, so for future reference, I placed the file containing my equations called ~equations.txt~ the root of the git repository, then ran from the root:
         #+begin_src bash
             cd src/
             . set.sh $absolute_path_to_equations_txt
             cd ..
             cd equations.txt_aux
             python generate_latex.py
         #+end_src
         I numbered the resulting files using Dired.
      3) Sort the images into classes based on their $\LaTeX$ code
         I created my images folder, and used this bit of bash magic to sort them into subfolders sharing their same names:
         #+begin_src bash
             for i in $(seq 0 $IMAGE_COUNT); do mkdir $i; mv $i.png $i/; done
         #+end_src

|----------------------------------+------------------------|
| Writing aspect                   | Transform name         |
|----------------------------------+------------------------|
| "wiggliness" or poor handwriting | ~A.ElasticTransform()~ |
| Orientation/rotation             |                        |
| Crossing                         |                        |
|----------------------------------+------------------------|
***** TODO Translation and scale
:PROPERTIES:
:ID:       9329ce83-9d36-442f-aa1b-0f878627bdb4
:END:
Although a textbook cited at the keras docs mentions that convolution layers /should/ be translation invariant, a cursory test of my model indicates they are definitely not. So, I need to alter the transformation stack accordingly. The model is also not resistant to the scale of the input, so I need to fix that as well.
***** TODO Stroke
:PROPERTIES:
:ID:       0f2a0cc9-68e0-42a9-802e-38cacc697079
:END:
The model is not resistant to different strokes. Depending on the way I implement the frontend, there may be no reason to train the model to recognize this.
***** TODO Choose a list of symbols
:PROPERTIES:
:ID:       8072149a-3aa0-40c8-a285-b706b3683d82
:END:
Initially, I chose a sample of 50 symbols picked mostly arbitrarily. The initial sample includes multiple sets of symbols which would be similarly drawn ($\prec$ and $<$, for example), and also made liberal use of "$\not$"'s (\not's). Because no large public facing database of small latex symbols in the model's format exists, and the transform stack is prohibitively computationally expensive, I had to decide what my relatively small data set will contain. I decided on a set of symbols composed mostly of some of the most popular mathematical symbols.

This might be a bit paradoxical, because those symbols which are most popular surely are the most remembered. This may be true, but it is also true that there are probably more beginning researchers and students in need of a reference for basic symbols than there are people who need to lookup the more esoteric symbols. Since [[https://detexify.kirelabs.org/classify.html][detexify]] exists and has a more comprehensive database, I choose for my tool to be more of a quick reference.

*** TODO Train the model
:PROPERTIES:
:ID:       abefb6da-43a5-4031-9747-c35c7e50b7da
:END:
** Frontend
:PROPERTIES:
:ID:       961df437-748a-46a6-a0d1-1ed053401c03
:END:
*** Drawing app
:PROPERTIES:
:ID:       f400d883-4a31-46e4-9432-ef5308bcccf4
:END:
*** Calling the model
:PROPERTIES:
:ID:       6bca650b-a082-4074-9e60-1c38613681e5
:END:
*** Formatting
:PROPERTIES:
:ID:       789efd6c-5f48-4b15-ae8b-c68910a84842
:END:
*** Hosting the site
:PROPERTIES:
:ID:       7d9e6fb7-1ce2-46ac-87e2-ae713d5b9f82
:END:
fly.io perhaps...
*** Notes on using Django
:PROPERTIES:
:ID:       c318ba1d-85f6-4e28-aef6-f329436f7fa1
:END:
- urlpatterns defined in an /app's/ urls.py are basically mappings from patterns in the url to methods within the views.py file for that app

- views.py is a collection of methods which are basically sub-pages of a site

  - methods in views.py have to return "HttpResponse" calls, but besides that can contain basically any python code

  - you can pass arguments to view by specifying their type and the argument they are assigned to in the following format:
    #+begin_src html
    '<int:question_id>/'
    #+end_src

- Templates an important part of views- in a yourappname/templates/yourappname/ dir, and are basically html files which can take in inputs etc.

  - You can assign variables in a given template to python objects using "contexts"

* HTML Page
:PROPERTIES:
:header-args:html: :exports body
:ID:       5102d1e2-df49-480c-8512-fca3fb1d5d20
:END:
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
** This website was made using org-mode. Crazy, right?
:PROPERTIES:
:ID:       983c827d-8e48-4d10-bd8b-fae432791365
:END:
This page was created and written entirely within org-mode- don't believe me? Here's an excerpt from the html of the next heading (when exported on its own):

#+begin_src html
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
#+end_src
**

** Some pictures and the code for my model
:PROPERTIES:
:ID:       fb7060fd-399d-4e64-be90-8a00d1630dfe
:END:
In this heading, we have some pictures which get embedded automatically. Here is a photo of a drawing I use to test the hand-drawn recognition of my model:

[[file:myinput.png]]

When I write this heading in org-mode, I don't see the image above unless I press a key combo (~C-c TAB~), so everything is out of the way just like in a language like CSS or HTML.

However, I also have the benefit of auto-correct and rendered text formatting, so I don't have to stare at a bunch of HTML tags (see [[*This website was made using org-mode. Crazy, right?][here]]).

Here's a photo of the performance of the most recent iteration of my model.

[[file:recentmodelperformance.png]]

#+RESULTS:

Also, here is a video:

#+begin_export html
<iframe width="560" height="315" src="https://www.youtube.com/embed/bwiLYb5Lv2I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
#+end_export
** Finally, I'll end with a famous Grothendieck quote
:PROPERTIES:
:ID:       171127b3-048c-4eed-86d1-8f2e6b28b842
:END:
#+begin_quote
A different image came to me a few weeks ago. The unknown thing to be known appeared to me as some stretch of earth or hard marl, resisting penetration... the sea advances insensibly in silence, nothing seems to happen, nothing moves, the water is so far off you hardly hear it... yet finally it surrounds the resistant substance.
                                        - Alexander Grothendieck[fn:4]
#+end_quote
** Footnotes
:PROPERTIES:
:ID:       2b1f1933-e425-4b96-9538-6e442e19779d
:END:
[fn:5] https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors


[fn:4] https://www.azquotes.com/quote/690590
* Testing exporting with blocks :devlog:
:PROPERTIES:
:ID:       52e68ed7-8f89-4484-90e5-580863d0b9b2
:END:
#+EXPORT_FILE_NAME: /home/shortcut/git/untexify/frontend/untexifyweb/testapp/templates/testapp/home.html
This is the test of an html export with html code-blocks inbuilt.
#+begin_src javascript :exports none
// matches elements of the document "document" (presumably the default instance of the Document() object instantiated by call "defer" in the script element) which have "class=myCanvas".[fn:5]
const canvas = document.querySelector('.myCanvas');
const width = canvas.width = window.innerWidth;
const height = canvas.height = window.innerHeight - 85;
const ctx = canvas.getContext('2d');

ctx.fillStyle = 'rgb(0,0,0)';
ctx.fillRect(0, 0, width, height);

const colorPicker = document.querySelector('input[type="color"]');
const sizePicker = 4;
const output = document.querySelector('.output');
const clearBtn = document.querySelector('button');

// covert degrees to radians
function degToRad(degrees) {
  return degrees * Math.PI / 180;
};

// update sizepicker output value

sizePicker.addEventListener('input', () => output.textContent = sizePicker.value);

// store mouse pointer coordinates, and whether the button is pressed
let curX;
let curY;
let pressed = false;

// update mouse pointer coordinates
document.addEventListener('mousemove', e => {
  curX = (window.Event) ? e.pageX : e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
  curY = (window.Event) ? e.pageY : e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
});

canvas.addEventListener('mousedown', () => pressed = true);

canvas.addEventListener('mouseup', () => pressed = false);

clearBtn.addEventListener('click', () => {
  ctx.fillStyle = 'rgb(0,0,0)';
  ctx.fillRect(0, 0, width, height);
});

function draw() {
  if (pressed) {
    ctx.fillStyle = colorPicker.value;
    ctx.beginPath();
    ctx.arc(curX, curY - 85, sizePicker.value, degToRad(0), degToRad(360), false);
    ctx.fill();
  }

  requestAnimationFrame(draw);
}

draw();
#+end_src
#+begin_export html  :noexport
<iframe width="560" height="315" src="https://www.youtube.com/embed/bwiLYb5Lv2I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
#+end_export
This is a thing
#+begin_export html
<!DOCTYPE html>
{% load static %}
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=width, initial-scale=5.0">
    <title>Canvas</title>
    <script src="{% static 'testapp/script.js' %}" defer></script>
  </head>
  <body>
    <canvas class="myCanvas" id="canvas" style="border: 3px solid black;">
      <p>Add suitable fallback here.</p>
    </canvas>
    <div class="toolbar">
        <form enctype="multipart/form-data" action="" method="post">
            {% csrf_token %}
            {{ form }}
            <input type="submit" value="Submit">
        </form>
      <button class="clearButton">Clear canvas</button>
    </div>
    <canvas class="background">
      </canvas>
      {{ symbol }}
  </body>
</html>
#+end_export
* test :devlog:
:PROPERTIES:
:ID:       62ad5016-a29b-4e80-a094-036a7233a21d
:END:
hello
* Notes on Django setup :ATTACH:devlog:
:PROPERTIES:
:ID:       9f218c40-f8cb-4786-ad33-e4cc0033717f
:END:
Getting a "Template does not exist" exception/error? [[https://stackoverflow.com/a/73620984][This thread]] worked for me.

** General django website work flow: (rough sketch):
:PROPERTIES:
:ID:       98da1dc0-2435-4534-a318-48d1d4413eaa
:END:
1. use ~manage.py startapp~
2. put app name in settings.py
3. point the maindir's urls.py to your app's urls.py
4. create views, forms, etc
5. [[https://docs.djangoproject.com/en/4.1/howto/static-files/][static files]]
   - when you *deploy*, you must follow that link's instructions.
     1) Simulate handwriting
        To do this I need a series of "transforms" which will piecewise randomly affect an aspect of a given image. This prevents overfitting, and in the first phase makes the model functional at all. Here are the aspects of the image I chose to transform:

        |----------------------------------+------------------------|
        | Writing aspect                   | Transform name         |
        |----------------------------------+------------------------|
        | "wiggliness" or poor handwriting | ~A.ElasticTransform()~ |
        | Sharpening                       | ~A.Sharpen()~          |
        | Uniform color                    | ~A.Equalize()~         |
        | Orientation/rotation             |                        |
        | Scale                            |                        |
        |----------------------------------+------------------------|
        - Translation and scale
          Although a textbook cited at the keras docs mentions that convolution layers /should/ be translation invariant, a cursory test of my model indicates they are definitely not. So, I need to alter the transformation stack accordingly. The model is also not resistant to the scale of the input, so I need to fix that as well.
        - Stroke
          The model is not resistant to different strokes. Depending on the way I implement the frontend, there may be no reason to train the model to recognize this.
        - Choose a list of symbols
          Initially, I chose a sample of 50 symbols picked mostly arbitrarily. The initial sample includes multiple sets of symbols which would be similarly drawn ($\prec$ and $<$, for example), and also made liberal use of $\not$'s (\not's). Because no large public facing database of small $\LaTeX$ symbols in the model's format exists, and the transform stack is prohibitively computationally expensive, I had to decide what my relatively small data set will contain. I decided on a set of symbols composed mostly of some of the most popular mathematical symbols.

          This might be a bit paradoxical, because those symbols which are most popular surely are the most remembered. This may be true, but it is also true that there are probably more beginning researchers and students in need of a reference for basic symbols than there are people who need to look up the more esoteric symbols. Since [[https://detexify.kirelabs.org/classify.html][detexify]] exists and has a more comprehensive database, I choose for my tool to be more of a quick reference.

   - [ ] Train the model
6. Frontend
   1) Hosting
      To host this project I used [[https://fly.io/][fly.io]] for its excellent integration with [[https://www.djangoproject.com/][Django]], which was used to construct the frontend. Fly.io's extremely simple installation instructions for a number of web-app libraries for popular languages, and it was overall very simple to use for someone not experienced in website hosting like myself.
   2) Website structure
      The frontend's structure was made entirely using Django, which was excellent for me as someone with lots of Python experience, and little HTML or CSS experience.

      Most of the interface between the model (which was made using another Python library, Tensorflow) and the page was handled in a single [[file:frontend/untexifyweb/testapp/views.py][views.py]] file. Python acted as the glue between Django and Tensorflow, which was extremely helpful and satisfying to work with.

      Those parts of the website I needed to actually delve into HTML for, were done almost entirely using org-mode's helpful HTML export. I could export large swaths of org-mode documents to a nice-looking CSS "frame", while embedding HTML within the plain org text for seamless integration into the final product.

** Exporting the code :ATTACH:
:PROPERTIES:
:EXPORT_FILE_NAME: ./test.html
:ID:       e22dd64e-ecbb-4798-96db-e210c3a84074
:END:
      This section contains the real code I am using for some Untexify's user-facing elements. They are written as code blocks, which are themselves tangled and merged together within Org-mode's exported HTML file, and are placed automatically where Django expects them to be.

      The utility of a literate configuration in this case is debatable, and it exists mostly as a proof-of-concept, and convenience since most of my other design lives within Emacs. With the use of [[https://orgmode.org/manual/CSS-support.html][custom stylesheet]] functionality, however, I can quickly alter the look of the site at anytime, with minimal effort.

      This block is the javascript code for the HTML canvas responsible for accepting user input, in the form of hand-drawn approximations of the symbol they are trying to look up.
      #+BEGIN_SRC javascript :exports code
      // matches elements of the document "document" (presumably the default instance of the Document() object instantiated by call "defer" in the script element) which have "class=myCanvas".
      const canvas = document.querySelector('.myCanvas');
      const width = canvas.width = window.innerWidth;
      const height = canvas.height = window.innerHeight - 85;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = 'rgb(0,0,0)';
      ctx.fillRect(0, 0, width, height);

      const colorPicker = document.querySelector('input[type="color"]');
      const sizePicker = 4;
      const output = document.querySelector('.output');
      const clearBtn = document.querySelector('button');

      // covert degrees to radians
      function degToRad(degrees) {
        return degrees * Math.PI / 180;
      };

      // update sizepicker output value

      sizePicker.addEventListener('input', () => output.textContent = sizePicker.value);

      // store mouse pointer coordinates, and whether the button is pressed
      let curX;
      let curY;
      let pressed = false;

      // update mouse pointer coordinates
      document.addEventListener('mousemove', e => {
        curX = (window.Event) ? e.pageX : e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
        curY = (window.Event) ? e.pageY : e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
      });

      canvas.addEventListener('mousedown', () => pressed = true);

      canvas.addEventListener('mouseup', () => pressed = false);

      clearBtn.addEventListener('click', () => {
        ctx.fillStyle = 'rgb(0,0,0)';
        ctx.fillRect(0, 0, width, height);
      });

      function draw() {
        if (pressed) {
          ctx.fillStyle = colorPicker.value;
          ctx.beginPath();
          ctx.arc(curX, curY - 85, sizePicker.value, degToRad(0), degToRad(360), false);
          ctx.fill();
        }

        requestAnimationFrame(draw);
      }

      draw();
      #+END_SRC
      Now, we render embed the user-facing HTML elements onto the page.
      #+begin_src html :exports code
      <!DOCTYPE html>
      {% load static %}
      <html lang="en-us">
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=width, initial-scale=5.0">
          <title>Canvas</title>
          <script src="{% static 'testapp/script.js' %}" defer></script>
        </head>
        <body>
          <canvas class="myCanvas" id="canvas" style="border: 3px solid black;">
            <p>Add suitable fallback here.</p>
          </canvas>
          <div class="toolbar">
              <form enctype="multipart/form-data" action="" method="post">
                  {% csrf_token %}
                  {{ form }}
                  <input type="submit" value="Submit">
              </form>
            <button class="clearButton">Clear canvas</button>
          </div>
          <canvas class="background">
            </canvas>
            {{ symbol }}
        </body>
      </html>
      #+end_src
* The Webdev Experience :devlog:
:PROPERTIES:
:ID:       b487fcad-3e76-4c7b-b5c0-a1abb8a8ca05
:END:
- NodeJS is a javascript runtime- like a python interpreter, but for JS
  - It lets you run ES6 javascript (the newest version of javascript), which allows you to use statements like =export= to make functions/variables/classes etc available to =import= from other javascript files.

    In essence, it is a way to complete javascript as a module system, like python

  - Most browsers do not support this type of ES6 javascript by default- you need to run a nodejs sever for that to work

    This is opposed to django, which is also a server. However, it is not the same as nodejs, and so you need special considerations to use ES6 with it.

- Bundlers are tools which, in various ways, allow one to use the new javascript syntax with older browsers

  Here is a list of examples of bundlers I have seen mentioned:

  + [[https://rollupjs.org/tutorial/#creating-your-first-bundle][Rollup]]

    I've started using this. Basically, I am going to want to do a few things:

    1. Edit =packages.json= (the file npm locks its packages into) to include a "build" script which will do everything

    2. Create a =rollup.config.js= to specify which files to bundle, and what format to do it in
       First, import this plugin which lets us parse all of its dependencies from just packages.json
       #+begin_src javascript :session readme :results output :tangle ./frontend/untexifyweb/testapp/rollup.config.js
        import json from '@rollup/plugin-json';
        #+end_src

        =export default= is just ES6 Javascript for "this is the thing I am exporting".
        #+begin_src javascript :session readme :results output :tangle ./frontend/untexifyweb/testapp/rollup.config.js
        export default {
            input: './frontend/untexifyweb/staticfiles/testapp/pixijs.js',
            output: {
                file: 'bundle.js',
                format: 'cjs'
            },
            plugins: [json()]
        };
            #+end_src

  + Vite

  + Webpack
** I am in hell
:PROPERTIES:
:ID:       a4d35653-d0a8-4dfb-9756-bae02f940c4f
:END:
Here's where I am now:
#+begin_src mermaid :file graph.png  :session readme
graph TD;
    rollup.config.js -->Rollup;
plugins & id[weird options] & id2[variables]-->package.json-->Rollup & Pixi.js;
id2-->Rollup-->Pixi.js;
id4[JS fiddling]-->Pixi.js & Rollup;
Pixi.js-->HTMLCanvas & Javascript-->Django;
#+end_src

#+RESULTS:
[[file:graph.png]]

And here's where I was before:
#+begin_src mermaid :file graph2.png  :session readme
graph TD;
id[JS fiddling]-->Javascript-->Django;
id2[HTML fiddling] & id3[CSS fiddling] -->HTMLCanvas-->Django;
#+end_src
#+RESULTS:
[[file:graph2.png]]


It would be super ideal if I could collapse HTMl and CSS fiddling away, and then use some library just for working with the Canvas and Javascript directly. I.e., a true SPA.

However, it's pretty clear at this point that Pixi.js is not the way forward:
- It uses ES6 Javascript, which means most out-of-the-box browsers don't run it, and that necessitates NodeJS or something equivalent.

- I can't use NodeJS because my project use Django as a webserver

- This means I have to /bundle/ Pixi.js, which has turned out to be highly difficult because of its unconventional exporting style.

  It doesn't simply export one "default" class or whatever, it has a bunch of different files. I'm not too sure, but it is complicated enough to have several "test" implementation projects on github, and the one working implementation I saw confirmed was complicated and depended on at least 4 or 5 different plugins.

This is the goal:

#+begin_src mermaid :file graph3.png  :session readme
graph TD;
id[JS fiddling] -->id2[ Magic JS SPA library]-->HTMLCanvas-->Django;
#+end_src

#+RESULTS:
[[file:graph3.png]]
